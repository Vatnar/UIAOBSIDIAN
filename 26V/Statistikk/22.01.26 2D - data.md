>[!definition] Population
>All data $\implies$ divide by $N$

>[!definition] Utvalg
>Part of data $\implies$ divide by $N-1$

## R 2D dataset
```R
Book1 <- read_excel("fil.xlsx")
plot(x=Book1$Høyde,y=Book1$Vekt, xlim=c(150,200), cex=0.5, pch=16,col="#123456")

```
`xlim` limits x values, input is a 2-vector, denoted by `c(x1,x2)`. `cex`: character expansion (scaling text), `pch`: point type. `col`: colour. 

### Guessing regression line
```R
a <- 80
b <- -0.1
yhat <-  a+b*x # forutsagt verdi
abline(a=a, b=b, col="maroon")
```
![[image 1.png|552x349]]
#### Difference between regression line and actual observation
```R
segments(x0=x,y0=y, x1=x, y1=yhat)
```
For all (x,y) pairs, draw a line from the y, to the line $\hat{y}$.

![[image-1 1.png|552x328]]

```R
a <- -60
b <- 0.8
```
We can tweak a,b to get better fit.
![[Images/image-3.png|552x359]]
Lets instead find a,b, and minimise total quadratic distance.

#### Linear Regression
We can do this in R
```R
linMod <- lm(y ~ x)
plot(x=Book1$Hoyde, y=Book1$Vekt, xlim(c(150,200),cex=0.5.,pch=16))
abline(linMod, col="maroon")
linSum <- summary(linMod)
```

| ![[Images/image-4.png]] | ![[Images/image-5.png]] |
| ---------------- | ---------------- |

To extract coefficients from linMod we do
```R
a <- linMod$Coefficients[1]
b <- linMod$Coefficients[1]
yhat <- a+b*x
segments(x0=x, y0=y, x1=x, y1=yhat, col="orange")
```
### With edited data
```R
HV <- read_excel("HV-main.xlsx")
x <- HV$Høyde
y <- HV$Vekt
plot(x=x, y=y, xlim=c(150,200),cex=0.5,pch=16,rgb(...))
linMod <- lm(y ~ x)
linMod <- (Vekt ~ Høyde, data=HV) # same
abline(linmod,col="maroon")
a <- linmod$coefficients[1]
b <- linmod$coefficients[2]
yhat <- a+b*x 
segments(x0=x,y0=y, x1=x, y1=yhat)
```
![[Images/image-6.png|552x378]]
## R-Squared
> [!definition] R-Squared
> R-Squared measures the proportion of variance in the dependent variable explained by the independent variable(s) in a regression model.
> $R^2=1-\frac{\Sigma(y_{i}-\hat{y_{i}})^2}{\Sigma(y_{i}-\bar{y})^{2}}$
> $y_{i}$, is the observed value, $\hat{y_{i}}$ predicted value, and $\bar{y}$ mean of observations. Values range from 0 (no explanation) to 1 (perfect fit), negative values can occur in bad models.

Summary gives R-squared: 0.3175...
$$R^2=1-\frac{\Sigma(y_{i}-\hat{y_{i}})^2}{\Sigma(y_{i}-\bar{y})^{2}}$$+
## Residuals
```R
# Normal Q-Q Plot
dy <- y -yhat
plot(x=x,y=dy,xlim=c(150,200),cex=0.5,pch=16,col=rgb(0,0.5,0.6))
abline(h=0,col="maroon")
n <- length(x)
segments(x0=x,y0=y, x1=x, y1=yhat)
# linSum residuals
linSum$Residuals
hist(dy,breaks=20)

# SSe calcullation, sum of squared errors
SSe = sum(dy^2)
se2 = SSe/(n-2) # estimates variance, divide by (n-2), prevents underestimating true error variance
se = sqrt(se2) # sigma: tilsvarer standardavvik

# se == linSum$Sigma
```


![[Images/image-8.png|552x572]]

## Scatterplots
```R
library(alr4)
library(car)
library(MASS)
head(mtcars)
scatterplot(x=mtcars$mpg, y=mtcars$wt)) # ligger i car
```
![[Images/image-9.png|552x345]]
## ScatterplotMatrix
`scatterplotMatrix(mtcars)`
gives a matrix

![[Images/image-10.png]]

#### Limit the matrix
`scatterplotMatrix(mtcars[4:7]`
![[Images/image-11.png|552x524]]
#### Specify columns
`scatterplotMatrix([c(1,5,11)])`

![[Images/image-12.png|552x553]]
#### Specify column names
```R
myCars <- mtcars[(c("mpg", "hp", "wt"))]
scatterplotMatrix(myCars)
```
![[Images/image-13.png|552x462]]
#### Transform the hp variable by taking the inverse
```R
# Transform hp-variable (x-variable)
mod_1 <- lm(mpg ~ I(1/hp), data=myCars)) # I(create a new column that is the inverse)
# mpg = a + b/hp
plot(x=myCars$hp,y=myCars$mpg,pch=14,col="blue")
```
![[Images/image-14.png|552x408]]
#### Draw the correlating line
```R
a <- mod_1$coefficients[1]
b <- mod_1$coefficients[2]
xLine <- seq(50, 340, 0.07)
yLine <- a + b/xLine
lines(xLine,yLine,col="maroon")
```
![[Images/image-15.png|552x390]]
#### Transform mpg variable instead
```R
# transform mpg-variable (y-variable)
mod_2 <- lm(I(1/mpg) ~ hp, data=myCars)) # I(create a new column that is the inverse)
# 1/mpg = gpm = a = b*hp


a2 <- mod_1$coefficients[1]
b2 <- mod_1$coefficients[2]
plot(x=myCars$hp,y=myCars$mpg,pch=14,col="blue")

xLine2 <- seq(50, 340, 0.07)
yLine2 <- 1/(a2 + b2*xLine2)
lines(xLine2,yLine2,col="maroon")
```
![[Images/image-16.png|552x427]]

### Which is better?
Multiple R-squared says $73\%$ of the variation in $y$ can be explained by $x$$...$

| summary(mod_2)<br> | summary(mod_1)    |
| ------------------ | ----------------- |
| ![[Images/image-17.png]]  | ![[Images/image-18.png]] |
|                    |                   |
### Another variable
We can do 1/x or 1/y. Now lets try with another variable
```R
scatterplot(myCars$mpg$,myCars$wt$)
```

![[Images/image-19.png]]
```R
mod_3 <- lm(mpg ~ I(1/wt), data = myCars)
summary(mod_3)
```
![[Images/image-20.png]]

### Both variables
```R
mod_4 <- lm(mpg ~ I(1/hp0) + I(1/wt), data=myCars)
summary(mod_4)
```

![[Images/image-21.png]]
```R
b_0 <- mod_4$coefficient[1]
b_1 <- mod_4$coefficient[2]
b_2 <- mod_4$coefficient[3]
# mpg = b_0 + b_1/hp + b_2/wt
```

# New example
```R
head(BGSall)

mod_BGS1 <- lm(ST18 ~ Sex + WT2 + HT2 + WT9 + HT9 + LG9 + ST9 + WT18 + HT18, data=BGSall)
summary(mod_BGS1)
```
![[Images/image-22.png]]
`anova(mod_BGS1` , siginificance based on order, DOnt use
and 
`Anova`, significance no matter order, use this
![[Images/image-23.png]]

## Make a new model with those significant
```R
modBGS1 <- lm(ST18 ~ Sex+HT9+ST9+WT18, data=BGSall)
summary(modBGS1)
```
![[Images/image-24.png]]
`Anova(ModBGS)`
![[Images/image-25.png]]

# Exam Exercises
R er volatilt.

![[image.png]]
i. Finn den linære regresjonslinjen y = a + bx
ii. finn den lin're regresjonslinjen ln(y) = A + Bx
iii. Gi en god grunn for å velge hver av de to regresjonsmodellene
### i.
```R
library(readxl)
Eksamen1 <- read_excel("Eksamen1.xlsx")
modEx1 <- lm(Eksamen1$y ~ Eksamen1$x)
a <- modEx1$coefficients[1]
b <- modeEx1$coefficients[2]
yHat <- a + b * Eksamen1$x
```
```R
plot(Eskamen1$y ~ Eksamen1$x)
abline(modEx1, col="maroon")
summary(modeEx1)
```
### ii.
```R
modEx2 = lm(Eksamen1$y ~ Eksamen1$x)
# ln(y) = a + bx
# y = exp(a + bx)
#   = exp(a) * exp(bx)
#   = 5.572813 * exp(bx)
# 
plot(Eskamen1$y ~ Eksamen1$x)
xLine = seq(2,10, 0.001)
yLine = 5.572813 * exp(0.5604*xLine)
lines(xLine, yLine,col="maroon")
```
# Project
Moduler -> Forprosjektmal etc.
1. Gjøre målinger. Mange målinger. Finne ut noe basert på målinger ( hvis det er significant. 
2. 