Prøve(prøvenr, enr, fornavn, dato, vid, vnavn, ph, temp)

enr -> fornavn
vid -> vnavn
prøvenr -> enr, dato, vid, ph, temp

PK = prøvenr

Hvis vi anatar at dato er en atomær datatype er tabellen på første normalform. Fast postlengde.
Den er også på andre normalform siden ID-felt kun har en kolonne.
Men ikke på tredje normalform siden fornavn avhenger av enr, og vnavn avhenger av vid som transitive avhengigheter.

For å normalisere til 3dje normalform flytter vi fornavn i en egen tabell, og vnavn ut i en egentabell med respektive enr og vid som primærnøkler. Dette gjør enr og vid om til fremmednøkler i prøvetabellen.

Prøve(prøvenr, enr, dato, vid, ph, temp)
Elev(enr, fornavn)
Vann(vid, vnavn)

Teststasjoner
a.
![[5q3ij.png]]
Introduserer ID i nærkontakt fordi vi ikke kan vite om at en person kan være nærkontakt til flere.
I ett mer robust system hadde det vært mer naturlig at nærkontakt knyttet sammenalle personene 
(tabellen) med prøveNr. Altså at nærkontakt blir en slags assosiativ enhet i mellom.
b.

Testklinikk(>TKKlinikk, kom, Legekode, HTlf)

Teststasjon(>TSKode, +TKKlinikk Tadr, Tmob, Teamkode)

Person(>PNr, PNavn, PAdr, PTlf, Pyrke, APlass)

Prøve(>PrNr, +TSKode, Tidspunkt, PNr, PRes)



Nærkontakt(>NID, +PrNr, Navn, Tlf)
1 1 Peter
2 1
3 2  Peter
4 2
5 3
6 2
7
8
9

```sql
# a.
SELECT *
FROM logg;
```
Bruker SELECT * for å hente ut alle kolonnene fra tabellen logg.
```sql
#b. 
SELECT dato, tlfnr_til, ant_minutter
FROM logg
WHERE tlfnr_fra="12345678"
AND ant_minutter IS NOT NULL
ORDER BY dato DESC; # nyeste først
```
Velger dato, tlfnr_til og ant_minutter med SELECT
fra tabellen logg.
Bruker WHERE For å kun velge radene som inneholder samtaler der avsender er 123455678 samtidig som at antall minutter ikke er null, siden ant_minutter != NULL betyr at det er en samtale og ikke melding.
Sorterer på nedadgående datao, ekller nyeste først.

```sql
#c. 
SELECT tlfnr_fra AS tlfnr, SUM(ant_minutter) AS tot_minutter, COUNT(tekst) AS ant_meldinger
# COUNT() teller ikke verdier som er NULL, derfor kan vi bruke dette for å finne ant_meldinger
FROM logg
WHERE YEAR(dato) = 2013 AND MONTH(dato) = 11
GROUP BY tlfnr_fra
```
Bruker AS for å lage alias for navnene slik at det matcher kravet i oppgaven.
Bruker SUM for å legge sammen antal minutter, og COUNT(Tekst) for å telle hvor mange meldinger det er. Vi kan bruke COUNT(tekst) siden COUNT ikke teller nullmerker.
Vi grupperer på tlfnr_fra siden vi har lyst til å finne antall minutter og meldinger per tlfnr.
```sql
#d.
SELECT l.dato, t.kunde_id AS SenderID, t2.kunde_id AS MottakerID, l.tekst AS Innhold 
FROM logg AS l, telefon AS t, telefon AS t2
WHERE l.tlfnr_fra = t.tlfnr AND l.tlfnr_til = t2.tlfnr
AND UPPER(tekst) LIKE '%SPION%'
ORDER BY l.dato;
```
Vi velger dato, kundeid for sennder,kundeid for mottaker, og meldingsteksten.
I FROM bruker vi AS l, for å lage et alias. Vi velger telefon tabellen to ganger siden vi skal ha inform,asjon om både sender og mottaker.
Vi JOiner (kobler) opp tabellene i WHERE og setter fra lik til den første t, og til lik den andre.
OG vi sjekker om teksten inneholder spion hvor som helst. Vi bruker upper(text) slik at dette funker uansett om de har brukt store eller små bokstaver i ordet.
Vi ordner/sorterer på dato.


5 DAT202_MM-107 - Vanlige_SP - ACID  
Hva står transaksjonsegenskapene ACID for. Hvilke andre konsepter innen databaser hjelper til å  
dekke egenskapene til hver enkelt bokstav i ACID prinsippet?
A - Atomicity
Atomicity betyr at operasjonen er udelelig
Konsepter som Rollback og commit hjelper med Atomicity. logging og journal
C - Consistency
constraints
integreitetsregler
	
I - Isolation
Låsing
Seriell utførelse
isolasjonsnivåer som read uncommited, read commited, 

D - Durability
Journaling logger
checkpointing
RAID systemer

6 DAT202_MM-107 - Vanlige_SP - Relasjoner  
Forklar om relasjoner mellom objekter, entiteter og tabeller og hvordan dette gjøres i både modell 
og tabell form?


13.
1. Denne spørringen vil gi ut alle navn som har 'er' inne i seg. Dette er fordi % markerer at det ikke betyr noe hva som står det. siden % er foran og etter.


I Codds relasjonsalgebra er en **tabell** (eller relasjon) faktisk en matematisk relasjon. En tabell består av rader (tupler) og kolonner (attributter), og hver rad representerer et tuppel i en matematisk mengde. Så ja, en tabell er en matematisk relasjon i relasjonsalgebra.



## MM-107_018
![[Pasted image 20250314133628.png]]


# Ulykkesdatabase

## Tabellstruktur
**Person**  
\_ID_, Fornavn, Etternavn, Fødselsdato, Kjønn  

**Kjøretoy**  
\_RegNr_, Merke, Modell, Årsmodell  

**Ulykke**  
\_UNr_, Dato, Vei  

**PersonIUlykke**  
\_UNr*_, \_ID*_, Rolle  

**KjøretoyIUlykke**  
\_UNr*_, \_RegNr*_

---
Person.ID og Ulykke.UNr er løpenumre som identifiserer henholdsvis personer og ulykker, mens  
Kjøretoy.RegNr er standard registreringsnummer. Om hver ulykke blir det lagret dato og på hvilken vei den  
inntraff. Koblingstabellene PersonIUlykke og KjøretoyIUlykke viser hvilke personer og kjøretøy som har vært  
involvert i hvilke ulykker. PersonIUlykke.Rolle viser hvilken rolle personer hadde, for eksempel sjåfør, passasjer  
eller fotgjenger. Eksempel data for tabellene ligger i illustrasjonen over. Du skal bruke SQL for å løse noen  
typiske oppgaver mot denne databasen. Tips: Du kan bruke funksjonen Year for å trekke ut årstallet fra en dato.  
f.eks. gir YEAR('2016-07-28') ut 2016
## SQL-oppgaver

### a) Hent ut informasjon om Fornavn, Etternavn, UNr og Rolle for alle personer som har vært involvert i en ulykke.
```sql
-- Versjon med JOIN-syntaks 
SELECT P.Fornavn, P.Etternavn, U.UNr, U.Rolle
FROM PersonIUlykke AS U
JOIN Person AS P ON U.ID = P.ID;

-- Versjon med gammeldags JOIN-syntaks 
SELECT P.Fornavn, P.Etternavn, U.UNr, U.Rolle
FROM PersonIUlykke AS U, Person AS P
WHERE U.ID = P.ID;
```
### b) Vis alle ulykker som inntraff på vei E134 i året 2010.

```sql
SELECT *
FROM Ulykke
WHERE Vei='E134' AND YEAR(Dato)=2010;
```

### c) Vis alle ulykker kjøretøyet med registreringsnummer NV33221 har vært innblandet i, sortert med hensyn på dato – fra eldst til yngst.
```SQL
SELECT U.*
FROM Ulykke AS U
JOIN KjøretoyIUlykke AS K ON K.UNr = U.UNr
WHERE K.RegNr='NV33221'
ORDER BY U.Dato ASC
```
### d) Vis antall ulykker i 2010 fordelt på bilmerker. Spørringen skal for hvert bilmerke vise antall ulykker som et kjøretøy av dette merket har vært involvert i.
```sql
SELECT k.Merke, COUNT(*) AS ant_ulykker
FROM Kjøretoy AS k
JOIN KjøretoyIUlykke AS kiu ON kiu.RegNr = k.RegNr
JOIN Ulykke AS U ON kiu.UNr = U.UNr
WHERE YEAR(U.dato)=2010
GROUP BY k.Merke;

SELECT k.Merke, COUNT(*) AS ant_ulykker
FROM Kjøretoy AS k, KjøretoyIUlykke AS kiu
WHERE kiu.RegNr = k.RegNr
GROUP BY k.Merke;
```


# Verkstedtimebestillinger

*Originale tabeller*
<span style="color:rgb(0, 176, 240)">Verkstedplass(PlassID, Løftebukktype, maks_tillat_vekt)</span>
<span style="color:rgb(0, 176, 240)">Ansatt(FNavn, ENavn, AnsattID)</span>
<span style="color:rgb(0, 176, 240)">Kunde(Navn, Telefon, RegNr)</span>

a) Hvis <span style="color:rgb(0, 176, 240)">maks_tillatt_vekt</span> avhenger av hvilken type løftebukk verkstedplassen har som er trolig er Verkstedplass-tabellen på 2NF. Hvis <span style="color:rgb(0, 176, 240)">maks_tillat_vekt </span>ikke avhenger av typen løftebukk er tabellen på tredje normalform.

Ansatt-tabellen er på 3. normalform siden ingen attributter avhenger av andre ikke-id-er.
Kunde-tabellen er på 3. normalform av samme grunn.

b) Hovednøklene burde være <span style="color:rgb(255, 0, 0)">PlassID</span>, <span style="color:rgb(255, 0, 0)">AnsattID</span> og <span style="color:rgb(255, 0, 0)">RegistreringsNr</span>. De to første er opplagte men den siste er viktig siden en og samme person kan ha flere biler, derfor er det smartere å identifisere basert på hver enkelt bil istedenfor hver enkel person. 
*Tabeller med primærnøkler*
<span style="color:rgb(0, 176, 240)">Verkstedplass(</span><span style="color:rgb(255, 0, 0)">*PlassID</span><span style="color:rgb(0, 176, 240)">, Løftebukktype, maks_tillat_vekt)</span>
<span style="color:rgb(0, 176, 240)">Ansatt(FNavn, ENavn,</span> *<span style="color:rgb(255, 0, 0)">*AnsattID</span><span style="color:rgb(0, 176, 240)">)</span>
<span style="color:rgb(0, 176, 240)">Kunde(Navn, Telefon,</span> <span style="color:rgb(255, 0, 0)">*RegNr</span><span style="color:rgb(0, 176, 240)">)</span>

c)
For en verkstedtimebestilling trenger vi åpenbart informasjon om Kunden, verkstedsplassen og når dette skjer. Hvilken ansatt som jobber på bilen er ikke nødvendig men kan hende er ønsket.

Det er viktig å koble sammen sted og tid først. Derfor definerer vi verkstedplassen med <span style="color:rgb(255, 0, 0)">PlassID</span>
og <span style="color:rgb(255, 0, 0)">Tid</span> som primærnøkler. 
<span style="color:rgb(0, 176, 240)">Verkstedtimebestilling(</span><span style="color:rgb(255, 0, 0)">*PlassID</span><span style="color:rgb(0, 176, 240)">,</span> <span style="color:rgb(255, 0, 0)">*Tid</span><span style="color:rgb(0, 176, 240)">, Registreringsnummer)</span>
Med registreringsnummer som fremmednøkkel.
<span style="color:rgb(0, 176, 240)">Verkstedtimebestilling(</span><span style="color:rgb(255, 0, 0)">*PlassID</span><span style="color:rgb(0, 176, 240)">,</span> <span style="color:rgb(255, 0, 0)">*Tid</span><span style="color:rgb(0, 176, 240)">, Registreringsnummer, AnsattID)</span>
Hvis det er ønskelig å knytte en ansatt til en bestilling.

d) Hensikten med fremmed nøkler er å kunne koble informasjon på tvers av tabeller og unngå redundanse. Fremmednøkler er et resultat av normalisering. Et alternativ for å unngå fremmednøkler er å denormalisere tabelllene og flytte informasjonen inn. I Verkstedstimebestilling kan vi for eksempel gjøre:
<span style="color:rgb(0, 176, 240)">Verkstedtimebestilling(</span><span style="color:rgb(255, 0, 0)">*PlassID</span><span style="color:rgb(0, 176, 240)">,</span> <span style="color:rgb(255, 0, 0)">*Tid</span><span style="color:rgb(0, 176, 240)">, Navn, Telefon, RegistreringsNr, FNavn, ENavn, AnsattID)</span>
Dette skaper redundanse, men kan være raskere hvis det er store tabeller som må multipliseres (kartesisk produkt).

# Robotgressklipper utleie.

Gressklipper (RGKode)
Modell(Modell) MAreal
StudentFirma(SFKode) Eier, SFTlf
Utleie(Tid) kunde, RGKode, pris
Kunde(KKode) KNavn KAdr KTlf

Kunde, Utleie 1-1