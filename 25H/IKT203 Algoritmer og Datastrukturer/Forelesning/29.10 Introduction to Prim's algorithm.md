Solve the "Network Problem"
Cheapest total cost in a MST (Minimum spanning tree)
Greedy algorithm. (Greedy because it claims something is the cheapest at the start, when it doesn't know, it makes the logical optimal choice at each step)
Dijkstra' algorithm is also greedy.


Prims:
Real world problem, you need to connect multiple cities with fiber optic cables for the lowest possible total cost, you don't need to connect every city to the other, just all need to be connected to network.

The 3 conditions:
1. Includes all vertices. No city is left isolated.
2. No cycles, cycle is redundant.
3. Minimum Total Weight: The sum of all edge weights in the tree is the smallest possible
It will always have exactly V-1 edges. E = V-1

A rooted tree has a clear hierarchy. There is one root node at the top and every other node is a descendant.
A minimum spanning tree, is a graph theory tree. This simply means its a sub-graph that meets two conditions
1. its connected
2. Its acyclic

How is the MST stored in Prim's Algorithm
- Concept, Prim's algorithm identifies a set of edges, you can return an edge list.
- More useful format, convert the edge list into an adjacency list.
Finds the edges, then we store them in a data structure that suits our next operation

 **Benefit 1** - Loop-Free Broadcasting
 - Since the MST is a tree it has no cycles.
 - This makes a perfect, efficient "backbone" for broadcasting data. .

**Benefit 2** - Identifying Critical Links
- The edges in the MST are the critical connections. If one of them breaks the entire network becomes disconnected.
- The edges from the original graph that are not in the MST are redundant paths. These are candidates for backup routes.
**Benefit 3** - The "Shortest Path" misconception
- Common trap. an MST guarantees path but does not guarantee shortest path
Prim's: Minimise cost for everyone
Dijkstra's, for one person.


#### HashSet
Check visited in O(1)
**Problem it solves**
If yo used a simple list or array to store visited nodes, you would not have to loop through the entire list to see if a node was already visited. Worst case this is an O(n) lookup.

Key Value pairs. 

**Min Heap**
1. The heap property: The single rule is: "A parent node must always be smaller than its children." This guarantees that the smallest item in the entire collection is always at the root (index 0 of the array). 
2. The Array "Tree" Trick: To save memory and be cache-friendly, the tree is stored in an array:

Operations
1. ExtractMin() operation (getting the cheapest edge)
- step 1: Take the item at index 0. this is the minimum. Easy.
- Step 2: this leaves a hole. To fill it, you take the very last item from the end of the array and move it to index 0.
- Step 3: This new root is probably too big, violatting the heap property.So you bubble it down, you bubble it down. YHou compare it to its children if its bigger than its smaller child you swap them. You repeat this bubbling down until its valid.
O Log n time
1. Add (item) operation adding a new edge
- Step 1: Add the new item to the very end of the array.
- Step 2: This new item might be smaller than its parent violating the heap property. So you bubble it up or sift up. You compare it to its parent. If its smaller you swap them. You repeat this bubbling up until its in a valid spot. This also takes at most O (log n ) time.
In Prim's. The min heap is the engine of the algorithm. 
